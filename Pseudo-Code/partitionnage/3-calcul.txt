
// ------------------------------ CALCUL ------------------------------

procédure hexaSaisi_To_HexaCalc(entF/sortF tab: s_tab) c'est
début
	i: entier;
	
	pour i de 1 à tab.nbHexa faire
		tab.t_hexa[i] := ENSEMBLE_HEXA[tab.t_hexa_calc[i]];
	finFaire
fin

procédure hexaCalc_To_HexaSaisi(entF/sortF tab: s_tab) c'est
début
	i: entier;

	pour i de 1 à tab.nbHexa faire
		si (tab.t_hexa[i]=='A' OU tab.t_hexa[i]=='a') alors
			tab.t_hexa_calc[i] := 10;
		sinon si (tab.t_hexa[i]=='B' OU tab.t_hexa[i]=='b') alors
			tab.t_hexa_calc[i] := 11;
		sinon si (tab.t_hexa[i]=='C' OU tab.t_hexa[i]=='c') alors
			tab.t_hexa_calc[i] := 12;
		sinon si (tab.t_hexa[i]=='D' OU tab.t_hexa[i]=='d') alors
			tab.t_hexa_calc[i] := 13;
		sinon si (tab.t_hexa[i]=='E' OU tab.t_hexa[i]=='e') alors
			tab.t_hexa_calc[i] := 14;
		sinon si (tab.t_hexa[i]=='F' OU tab.t_hexa[i]=='f') alors
			tab.t_hexa_calc[i] := 15;
		sinon
			tab.t_hexa_calc[i] := charInt(entE tab.t_hexa[i]);
		finSi
	finFaire
fin

procédure entToBin(entF/sortF tab: s_tab) c'est
début
	i, dividende, diviseur, quotient, reste: entier;
	i := 1;

	dividende := tab.resEnt;
	diviseur := 2;
	reste := dividende % diviseur;
	quotient := (dividende - reste) / diviseur;

	tab.t_bin[i] := reste;

	tantque (quotient > 0) faire
		i++;
		dividende := quotient;
		reste := dividende % diviseur;
		quotient := (dividende - reste) / diviseur;
		tab.t_bin[i] := reste;
	finFaire

	tab.nbBin := i;
fin

procédure entToHexa(entF/sortF tab: s_tab) c'est
début
	i, dividende, diviseur, quotient, reste: entier;
	i := 1;

	dividende := tab.resEnt;
	diviseur := 16;
	reste := dividende % diviseur;
	quotient := (dividende - reste) / diviseur;

	tab.t_hexa_calc[i] := reste;

	tantque (quotient != 0) faire
		i++;
		dividende := quotient;
		reste := dividende % diviseur;
		quotient := (dividende - reste) / diviseur;
		tab.t_hexa_calc[i] := reste;
	finFaire

	tab.nbHexa := i;

	hexaCalc_To_HexaSaisi(entE/sortE tab);
fin

procédure binToEnt(entF/sortF tab : s_tab) c'est
début
	somme, i, j: entier;
	somme := 0;
	j := 0;

	// Parcours du tableau à l'envers car un binaire se lit de droite à gauche
	pour i de tab.nbBin à 1 faire
		somme := somme + (tab.t_bin[i] * 2^j); 
		j++;
	finFaire
	
	tab.resEnt := somme;
fin

procédure hexaToEnt(entF/sortF tab: s_tab) c'est
début
	hexaSaisi_To_HexaCalc(entE/sortE tab);

	somme, i, j: entier;
	somme := 0;
	j := 0;

	pour i de tab.nbHexa à 1 faire
		somme := somme + (tab.t_hexa_calc[i] * 16^j); 
	finFaire
	
	tab.resEnt := somme;
fin