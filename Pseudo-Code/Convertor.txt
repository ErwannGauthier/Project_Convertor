
// ------------------------------ CONSTANTES ET STRUCTURES ------------------------------

// Affichage
constante chaine() TETE := "+-----------------------------------------------+";
constante chaine() ESPACE := "|\t\t\t\t\t\t|";

// Saisi-Calcul
// Chiffre max : 1 048 575, (FFFFF)16, (11111111111111111111)2

constante entier MAX_ENT := 1 048 575;

constante entier MAX_TAB_BIN := 20; // car tableau en pseudo-code : 1..MAX, alors qu'en C : 0..MAX-1
type tabBin = tableau[1..MAX_TAB_BIN] d'entier;

constante entier MAX_TAB_HEXA := 5;
type tabHexa = tableau[1..MAX_TAB_HEXA] de caractere;
type tabHexaCalc = tableau[1..MAX_TAB_HEXA] de entier;

type s_tab = structure
début
	resEnt : entier;

	t_bin: tabBin;
	nbBin: entier;
	saisiBin: booléen;

	t_hexa: tabHexa;
	t_hexa_calc: tabHexaCalc
	nbHexa: entier;
	saisiHexa: booléen;
fin

// Ensemble des valeurs hexadécimales possibles
constante entier MAX_ENSEMBLE_HEXA := 22
constante caractere ENSEMBLE_HEXA[1..MAX_ENSEMBLE_HEXA] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'};

// ------------------------------ SAISIE ------------------------------

fonction charInt(entF c: caractère) délivre entier c'est
début
	charInt: entier;
	charInt := c - '0';

	retourne charInt;
fin

procédure initTab(sortF tab: s_tab) c'est
début
	tab.nbBin := 0;
	tab.saisiBin := FAUX;

	tab.nbHexa := 0;
	tab.saisiHexa := FAUX;
fin

procédure saisiEnt(entF/sortF tab: s_tab) c'est
début
	ecrireEcran("Entrer le nombre entier : ");
	lireClavier(tab.resEnt);

	si (tab.resEnt < 0) alors
		ecrireEcran("ERREUR: Vous avez saisi un entier négatif.");
		ecrireEcran("Saisissez un entier positif : ");
		saisiEnt(entE/sortE tab);

	sinon si (tab.resEnt > MAX_ENT) alors
		tab.resEnt := MAX_ENT;
	finSi
fin

procédure saisiBin(entF/sortF tab: s_tab) c'est
début

// ----- PARTIE SAISI -----

	tab.saisiBin := VRAI;
	saisi: chaine(MAX_TAB_BIN);

	ecrireEcran("Entrer le nombre binaire : ");
	lireClavier(saisi);

	// Vérifie que la chaine n'est pas trop grande
	tantque (taille(saisi) > MAX_TAB_BIN) faire
	début
		ecrireEcran("Erreur, votre nombre binaire ne peut pas dépasser les 20 chiffres. \nRecommencez : ");
		lireClavier(saisi);
	finFaire

	// Vérifie que le premier caractère vaut 0 ou 1 sinon Erreur
	tanque ((saisi(0) != '0') ET (saisi(0) != '1')) faire
	début
		ecrireEcran("Erreur: un nombre binaire est constitué exclusivement de 0 et de 1.");
		ecrireEcran("Entrer un nombre binaire :");
		lireClavier(saisi);

		tantque (taille(saisi) > MAX_TAB_BIN) faire
		début
			ecrireEcran("Erreur, votre nombre binaire ne peut pas dépasser les 20 chiffres. \nRecommencez : ");
			lireClavier(saisi);
		finFaire
	finFaire

// ----- PARTIE CONVERTION -----

	i: entier;
	i := 0;

	tantque ((i <= MAX_SAISI_BIN) ET ((saisi(i)=='0') OU (saisi(i)=='1'))) faire
		tab.t_bin[i] := charInt(entE saisi(i));
		i++;
	finFaire

	tab.nbBin := i;
fin

// Retourne true si saisi se trouve dans l'ensemble hexadecimal, false sinon.
fonction estHexa(entF saisi: caractère) délivre booléen c'est
début
	trouve: booléen;
	trouve := FAUX;

	i: entier;
	i := 0;

	tantque ((i < MAX_ENSEMBLE_HEXA) && (trouve == FAUX)) faire
		si (saisi - ENSEMBLE_HEXA[i] == 0) alors
			trouve := VRAI;
		finSi
		i++;
	finFaire

	retourne trouve;
fin

procédure saisiHexa(entF/sortF tab: s_tab) c'est
début

// ----- PARTIE SAISI -----

	tab.saisiHexa := VRAI;
	saisi: chaine(MAX_TAB_HEXA);

	ecrireEcran("Entrer le nombre héxadecimal : ");
	lireClavier(saisi);

	//Vérifie que la chaine saisie n'est pas trop grande.
	tantque (taille(saisi) > MAX_TAB_HEXA) faire
		ecrireEcran("Erreur, votre nombre hexadécimal ne peut pas dépasser les 5 chiffres.");
		ecrireEcran("Entrer un nombre hexadécimal :");
		lireClavier(saisi);
	finFaire

	//Vérifie que le premier caractère est dans l'ensemble hexadécimal si non ressaisir.
	tantque (estHexa(entE saisi(0) == FAUX) faire
		ecrireEcran("Erreur, un nombre hexadécimal est constitué de chiffre et/ou des lettres A à F.\n");
        	ecrireEcran("Entrer un nombre hexadécimal : ");
		lireClavier(saisi);

		tantque (taille(saisi) > MAX_TAB_HEXA) faire
			ecrireEcran("Erreur, votre nombre hexadécimal ne peut pas dépasser les 5 chiffres.");
			ecrireEcran("Entrer un nombre hexadécimal :");
			lireClavier(saisi);
		finFaire
	finFaire

// ----- PARTIE CONVERTION -----

	i: entier;
	i := 0;

	tantque ((i < MAX_TAB_HEXA) && (estHexa(entE saisi(i) == true)) faire
		tab.t_hexa[i] := saisi(i);
		i++;
	finFaire

	tab.nbHexa := i;
fin

// ------------------------------ CALCUL ------------------------------

procédure hexaSaisi_To_HexaCalc(entF/sortF tab: s_tab) c'est
début
	i: entier;
	
	pour i de 1 à tab.nbHexa faire
		tab.t_hexa[i] := ENSEMBLE_HEXA[tab.t_hexa_calc[i]];
	finFaire
fin

procédure hexaCalc_To_HexaSaisi(entF/sortF tab: s_tab) c'est
début
	i: entier;

	pour i de 1 à tab.nbHexa faire
		si (tab.t_hexa[i]=='A' OU tab.t_hexa[i]=='a') alors
			tab.t_hexa_calc[i] := 10;
		sinon si (tab.t_hexa[i]=='B' OU tab.t_hexa[i]=='b') alors
			tab.t_hexa_calc[i] := 11;
		sinon si (tab.t_hexa[i]=='C' OU tab.t_hexa[i]=='c') alors
			tab.t_hexa_calc[i] := 12;
		sinon si (tab.t_hexa[i]=='D' OU tab.t_hexa[i]=='d') alors
			tab.t_hexa_calc[i] := 13;
		sinon si (tab.t_hexa[i]=='E' OU tab.t_hexa[i]=='e') alors
			tab.t_hexa_calc[i] := 14;
		sinon si (tab.t_hexa[i]=='F' OU tab.t_hexa[i]=='f') alors
			tab.t_hexa_calc[i] := 15;
		sinon
			tab.t_hexa_calc[i] := charInt(entE tab.t_hexa[i]);
		finSi
	finFaire
fin

procédure entToBin(entF/sortF tab: s_tab) c'est
début
	i, dividende, diviseur, quotient, reste: entier;
	i := 1;

	dividende := tab.resEnt;
	diviseur := 2;
	reste := dividende % diviseur;
	quotient := (dividende - reste) / diviseur;

	tab.t_bin[i] := reste;

	tantque (quotient > 0) faire
		i++;
		dividende := quotient;
		reste := dividende % diviseur;
		quotient := (dividende - reste) / diviseur;
		tab.t_bin[i] := reste;
	finFaire

	tab.nbBin := i;
fin

procédure entToHexa(entF/sortF tab: s_tab) c'est
début
	i, dividende, diviseur, quotient, reste: entier;
	i := 1;

	dividende := tab.resEnt;
	diviseur := 16;
	reste := dividende % diviseur;
	quotient := (dividende - reste) / diviseur;

	tab.t_hexa_calc[i] := reste;

	tantque (quotient != 0) faire
		i++;
		dividende := quotient;
		reste := dividende % diviseur;
		quotient := (dividende - reste) / diviseur;
		tab.t_hexa_calc[i] := reste;
	finFaire

	tab.nbHexa := i;

	hexaCalc_To_HexaSaisi(entE/sortE tab);
fin

procédure binToEnt(entF/sortF tab : s_tab) c'est
début
	somme, i, j: entier;
	somme := 0;
	j := 0;

	// Parcours du tableau à l'envers car un binaire se lit de droite à gauche
	pour i de tab.nbBin à 1 faire
		somme := somme + (tab.t_bin[i] * 2^j); 
		j++;
	finFaire
	
	tab.resEnt := somme;
fin

procédure hexaToEnt(entF/sortF tab: s_tab) c'est
début
	hexaSaisi_To_HexaCalc(entE/sortE tab);

	somme, i, j: entier;
	somme := 0;
	j := 0;

	pour i de tab.nbHexa à 1 faire
		somme := somme + (tab.t_hexa_calc[i] * 16^j); 
	finFaire
	
	tab.resEnt := somme;
fin

// ------------------------------ AFFICHAGE ------------------------------

procédure affichMenu() c'est
début
	ecrireEcran(TETE);
	ecrireEcran(ESPACE);
	ecrireEcran("| De quel type est votre chiffre ?\t\t|");
	ecrireEcran("|\t 1 : Entier\t\t\t\t|");
	ecrireEcran("|\t 2 : Binaire\t\t\t\t|");
	ecrireEcran("|\t 3 : Hexadecimal\t\t\t|");
	ecrireEcran("|\t 4 : Quitter\t\t\t\t|");
	ecrireEcran(ESPACE);
	ecrireEcran(TETE);
fin

procédure affichBin(entF tab: s_tab) c'est
début
	i: entier;

	si (tab.saisiBin == VRAI) alors
		pour i de 1 à tab.nbBin faire
			ecrireEcran(tab.t_bin[i]);
		finFaire
	sinon
		pour i de tab.nbBin à 1 faire
			ecrireEcran(tab.t_bin[i]);
		finFaire
	finSi
fin

procédure affichHexa(entF tab: s_tab) c'est
début
	i: entier;

	si (tab.saisiHexa == VRAI) alors
		pour i de 1 à tab.nbHexa faire
			ecrireEcran(tab.t_hexa[i]);
		finFaire
	sinon
		pour i de tab.nbHexa à 1 faire
			ecrireEcran(tab.t_hexa[i]);
		finFaire
	finSi
fin

procédure affichRes(entF tab: s_tab) c'est
début
	ecrireEcran(TETE);
	ecrireEcran(ESPACE);
	ecrireEcran("|	Entier :", tab.resEnt);
	ecrireEcran(ESPACE);
	ecrireEcran("|	Binaire :");
	affichBin(entE tab);
	ecrireEcran(ESPACE);
	ecrireEcran("|	Hexadécimal :");
	affichHexa(entE tab);
	ecrireEcran(ESPACE);
	ecrireEcran(TETE);
fin

// ------------------------------ MAIN ------------------------------

programme main c'est
début 
	resSwitch: entier;

	continue: booléen;
	continue := VRAI;

	tab: s_tab;
	
	tantque (continue != FAUX) faire

		initTab(sortE tab);

		affichMenu();
		lireClavier(resSwitch);

		selon resSwitch faire
			cas 1:
				saisiEnt(entE/sortE tab);
				entToBin(entE/sortE tab);
				entToHexa(entE/sortE tab);
				affichRes(entE tab);

			cas 2:
				saisiBin(entE/sortE tab);
				binToEnt(entE/sortE tab);
				entToHexa(entE/sortE tab);
				affichRes(entE tab);

			cas 3:
				saisiHexa(entE/sortE tab);
				hexaToEnt(entE/sortE tab);
				entToBin(entE/sortE tab);
				affichRes(entE tab);

			cas 4:	ecrireEcran("Aurevoir.");
				continue := FAUX;

			default : ecrireEcran("Erreur : Veuillez rentrer 1, 2, 3 ou 4");
		finSelon

	finFaire
fin